<html>

<head>
    <link rel="stylesheet" type="text/css" href="//rawgithub.com/Caged/d3-tip/master/examples/example-styles.css">
</head>

<body>
    <div id="timeline">

    </div>
    <style>
        /* Make the chart container fill the page using CSS. */

        #timeline {
            position: fixed;
            left: 0px;
            right: 0px;
            top: 0px;
            bottom: 0px;
        }
    </style>
    <script src="//cdnjs.cloudflare.com/ajax/libs/d3/4.7.4/d3.min.js"></script>
    <script src="//rawgit.com/Caged/d3-tip/master/index.js"></script>

    <script>
        Number.random = function(minimum, maximum, precision) {
            minimum = minimum === undefined ? 0 : minimum;
            maximum = maximum === undefined ? 9007199254740992 : maximum;
            precision = precision === undefined ? 0 : precision;

            var random = Math.random() * (maximum - minimum) + minimum;

            return parseFloat(random.toFixed(precision));
        }


        var margin = {
            top: 60,
            right: 50,
            bottom: 60,
            left: 50
        };

        function render(data) {
            var lineThickness = 0.0012 * height;
            var circleRadius = lineThickness;

            // Min and max dates
            data.minDate = d3.min(data, function(d) {
                return d.term_start;
            });
            data.maxDate = d3.max(data, function(d) {
                return d.term_end;
            });

            var x = d3.scaleTime()
                .domain([new Date(1915, 01, 01), new Date(2020, 01, 01)])
                .range([0, width]);

            var y = d3.scaleLinear()
                .domain([0, d3.max(data, function(d) {
                    return d.stream;
                })])
                .range([height, 0]);

            // Enter
            var wrapper = svg
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Tooltip details
            var tooltip = d3.tip()
                .attr("class", "d3-tip")
                .offset([-10, 0])
                .html(function(d) {
                    return d.name + ": " + d3.timeFormat("%Y")(d.term_start) + d.byelection +
                        " - " + d3.timeFormat("%Y")(d.term_end);
                })

            wrapper.call(tooltip);

            //////////////////////////////////////////////////////////////
            //////////////////////// Voronoi /////////////////////////////
            //////////////////////////////////////////////////////////////

            //Initiate the voronoi function
            //Use the same variables of the data in the .x and .y as used in the cx and cy of the circle call
            //The clip extent will make the boundaries end nicely along the chart area instead of splitting up the entire SVG
            //(if you do not do this it would mean that you already see a tooltip when your mouse is still in the axis area, which is confusing)
            var voronoi = d3.voronoi()
                .x(function(d) {
                    return x(d.term_start);
                })
                .y(function(d) {
                    return y(d.stream);
                })
                .extent([
                    [0, 0],
                    [width, height]
                ]);

            //Initiate a group element to place the voronoi diagram in
            var voronoiGroup = wrapper.append("g")
                .attr("class", "voronoiWrapper");
            //Create the Voronoi diagram
            voronoiGroup.selectAll("path")
                .data(voronoi(data)) //Use vononoi() with your dataset inside
                .enter().append("path")
                .attr("d", function(d, i) {
                    return "M" + d.join("L") + "Z";
                })
                .datum(function(d, i) {
                    console.log(d.point);
                    return d.point;
                })
                //Give each cell a unique class where the unique part corresponds to the circle classes
                .attr("class", function(d, i) {
                    return "voronoi " + d.clean_name;
                })
                .style("stroke", "#2074A0") //I use this to look at how the cells are dispersed as a check
                .style("fill", "none")
                .style("pointer-events", "all")
                .on("mouseover", tooltip.show)
                .on("mouseout", tooltip.hide);

            var clippedArea = wrapper.append("g")
                .attr("id", "clippedArea")
                .attr("clip-path", "url(#clip)")
                .style("pointer-events", "all")

            var pointsGroup = clippedArea
                .append("g")
                .attr("id", "points")

            wrapper.append("clipPath")
                .attr("id", "clip")
                .append("rect")
                .attr("width", width)
                .attr("height", height);
            var instance = pointsGroup
                .selectAll("g")
                .data(data)
                .enter()
                .append("g")

            var xAxis = d3.axisBottom(x)
            var gX = wrapper.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .call(xAxis);

            var yAxis = d3.axisLeft(y)
            var gY = wrapper.append("g")
                .attr("class", "y axis")
                .call(yAxis);
            // Add line connecting start and end of term
            instance
                .append("line")
                .attr("class", "line-connect")
                .style("stroke-width", lineThickness)
                .on("mouseover", tooltip.show)
                .on("mouseout", tooltip.hide);
            // Add circle for start and end
            instance
                .append("circle")
                .attr("r", circleRadius)
                .attr("class", "term-start")
                .on("mouseover", tooltip.show)
                .on("mouseout", tooltip.hide);
            instance
                .append("circle")
                .attr("r", circleRadius)
                .attr("class", "term-end")
                .on("mouseover", tooltip.show)
                .on("mouseout", tooltip.hide);

            // Update
            instance.selectAll(".line-connect")
                .attr("x1", function(d) {
                    return x(d.term_start)
                })
                .attr("x2", function(d) {
                    return x(d.term_end)
                })
                .attr("y1", function(d) {
                    return y(d.stream)
                })
                .attr("y2", function(d) {
                    return y(d.stream)
                })
                .attr("stroke", function(d) {
                    return d.party;
                })

            instance.selectAll(".term-start")
                .attr("cx", function(d) {
                    return x(d.term_start)
                })
                .attr("cy", function(d) {
                    return y(d.stream)
                })
                .attr("fill", function(d) {
                    return d.party
                })

            instance.selectAll(".term-end")
                .attr("cx", function(d) {
                    return x(d.term_end)
                })
                .attr("cy", function(d) {
                    return y(d.stream)
                })
                .attr("fill", function(d) {
                    return d.party
                })

            // Zoom
            var zoom = d3.zoom()
                .scaleExtent([0.9, 40])
                .on("zoom", zoomed);
            svg.call(zoom);

            function zoomed() {
                pointsGroup.attr("transform", d3.event.transform)
                gX.call(xAxis.scale(d3.event.transform.rescaleX(x)));
                gY.call(yAxis.scale(d3.event.transform.rescaleY(y)));
            }
            // Exit
            instance.exit().remove();
        }

        var svg = d3.select(timeline).append("svg")
        function draw_graph() {
            d3.selectAll("g > *").remove()
            var timeline = document.getElementById("timeline")
                // Chart dimensions - use parent div size
            width = timeline.clientWidth - margin.left - margin.right,
            height = timeline.clientHeight - margin.top - margin.bottom;
            svg
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            console.log("resize")
            d3.csv("mps_over_time.csv", function(d) {
                var parseDate = d3.timeParse("%Y-%m-%d");
                return {
                    name: d.name,
                    constituency: d.constituency,
                    term_start: parseDate(d.term_start),
                    term_end: parseDate(d.term_end),
                    party: d.party,
                    byelection: (d.byelection == "TRUE"),
                    clean_name: d.clean_name,
                    stream: +d.stream
                };
            }, function(data) {
                render(data);
            });
        }
        draw_graph()
        window.addEventListener('resize', draw_graph);
    </script>
</body>

</html>
