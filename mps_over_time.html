<html>

<head>
    <link rel="stylesheet" type="text/css" href="//rawgithub.com/Caged/d3-tip/master/examples/example-styles.css">
</head>

<body>
    <div id="timeline">

    </div>
    <style>
        /* Make the chart container fill the page using CSS. */

        #timeline {
            position: fixed;
            left: 0px;
            right: 0px;
            top: 0px;
            bottom: 0px;
        }
    </style>
    <script src="//cdnjs.cloudflare.com/ajax/libs/d3/4.7.4/d3.min.js"></script>
    <script src="//rawgit.com/Caged/d3-tip/master/index.js"></script>

    <script>
        Number.random = function(minimum, maximum, precision) {
            minimum = minimum === undefined ? 0 : minimum;
            maximum = maximum === undefined ? 9007199254740992 : maximum;
            precision = precision === undefined ? 0 : precision;

            var random = Math.random() * (maximum - minimum) + minimum;

            return parseFloat(random.toFixed(precision));
        }

        var circleRadius = 1;
        var lineThickness = 1;

        var margin = {
            top: 60,
            right: 50,
            bottom: 60,
            left: 50
        };

        function render(data) {

            // Min and max dates
            data.minDate = d3.min(data, function(d) {
                return d.term_start;
            });
            data.maxDate = d3.max(data, function(d) {
                return d.term_end;
            });

            var x = d3.scaleTime()
                .domain([new Date(1915, 01, 01), new Date(2020, 01, 01)])
                .range([0, width]);

            var y = d3.scaleLinear()
                .domain([0, d3.max(data, function(d) {
                    return d.stream;
                })])
                .range([height, 0]);

            // Enter
            var wrapper = svg
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            var tooltip = d3.tip()
                .attr("class", "d3-tip")
                .offset([-10, 0])
                .html(function(d) {
                    return d.name + ": " + d3.timeFormat("%Y")(d.term_start) +
                    " - " + d3.timeFormat("%Y")(d.term_end);
                })

            wrapper.call(tooltip);

            //////////////////////////////////////////////////////////////
            //////////////////////// Voronoi /////////////////////////////
            //////////////////////////////////////////////////////////////

            //Initiate the voronoi function
            //Use the same variables of the data in the .x and .y as used in the cx and cy of the circle call
            //The clip extent will make the boundaries end nicely along the chart area instead of splitting up the entire SVG
            //(if you do not do this it would mean that you already see a tooltip when your mouse is still in the axis area, which is confusing)
            var voronoi = d3.voronoi()
            	.x(function(d) { return x(d.term_start); })
            	.y(function(d) { return y(d.stream); })
            	.extent([[0, 0], [width, height]]);

            //Initiate a group element to place the voronoi diagram in
            var voronoiGroup = wrapper.append("g")
            	.attr("class", "voronoiWrapper");
            //Create the Voronoi diagram
            voronoiGroup.selectAll("path")
            	.data(voronoi(data)) //Use vononoi() with your dataset inside
            	.enter().append("path")
            	.attr("d", function(d, i) { return "M" + d.join("L") + "Z"; })
            	.datum(function(d, i) { console.log(d.point);return d.point; })
            	//Give each cell a unique class where the unique part corresponds to the circle classes
            	.attr("class", function(d,i) { return "voronoi " + d.clean_name; })
            	.style("stroke", "#2074A0") //I use this to look at how the cells are dispersed as a check
            	.style("fill", "none")
            	.style("pointer-events", "all")
            	.on("mouseover", tooltip.show)
                .on("mouseout", tooltip.hide);


            var pointsGroup = wrapper
                .append("g")
                .attr("id", "points")

            var instance = pointsGroup
                .selectAll("g")
                .data(data)
                .enter()
                .append("g")

            wrapper.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));

            wrapper.append("g")
                .attr("class", "y axis")
                .call(d3.axisLeft(y));
            // Add line connecting start and end of term
            instance
                .append("line")
                .attr("class", "line-connect")
                .style("stroke-width", lineThickness)
                .on("mouseover", tooltip.show)
                .on("mouseout", tooltip.hide);
            // Add circle for start and end
            instance
                .append("circle")
                .attr("r", circleRadius)
                .attr("class", "term-start")
                .on("mouseover", tooltip.show)
                .on("mouseout", tooltip.hide);
            instance
                .append("circle")
                .attr("r", circleRadius)
                .attr("class", "term-end")
                .on("mouseover", tooltip.show)
                .on("mouseout", tooltip.hide);

            // Update
            instance.selectAll(".line-connect")
                .attr("x1", function(d) {
                    return x(d.term_start)
                })
                .attr("x2", function(d) {
                    return x(d.term_end)
                })
                .attr("y1", function(d) {
                    return y(d.stream)
                })
                .attr("y2", function(d) {
                    return y(d.stream)
                })
                .attr("stroke", function(d) {
                    return d.party;
                })

            instance.selectAll(".term-start")
                .attr("cx", function(d) {
                    return x(d.term_start)
                })
                .attr("cy", function(d) {
                    return y(d.stream)
                })
                .attr("fill", function(d) {
                    return d.party
                })

            instance.selectAll(".term-end")
                .attr("cx", function(d) {
                    return x(d.term_end)
                })
                .attr("cy", function(d) {
                    return y(d.stream)
                })
                .attr("fill", function(d) {
                    return d.party
                })

            // Exit
            instance.exit().remove();
        }
        var timeline = document.getElementById("timeline")
            // Chart dimensions - use parent div size
        width = timeline.clientWidth - margin.left - margin.right,
            height = timeline.clientHeight - margin.top - margin.bottom;
        var svg = d3.select(timeline).append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)

        var data = d3.csv("mps_over_time.csv", function(d) {
            var parseDate = d3.timeParse("%Y-%m-%d");
            return {
                name: d.name,
                term_start: parseDate(d.term_start),
                term_end: parseDate(d.term_end),
                party: d.party,
                clean_name: d.clean_name,
                stream: +d.stream
            };
        }, function(data) {
            render(data);
        });
    </script>
</body>

</html>
